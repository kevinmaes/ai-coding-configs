# CLAUDE.md - Global Instructions for Claude Code

## Overview

This file contains global instructions and preferences that Claude should follow across all projects. These instructions override default behaviors.

## Code Style & Conventions

### General Principles

- Prefer functional programming over OOP
- Use pure functions for testability
- Use factory functions instead of classes when instantiation is needed
- Error handling: Use error boundaries at top level, scope them lower when needed

### Language-Specific Guidelines

#### JavaScript/TypeScript

- Always use TypeScript
- Use named exports exclusively (no default exports)
- React: Use only functional components with hooks
- React: Use PascalCase for component names
- React: Define props as interfaces, inline for small props or at top of file for larger ones
- React: Prefer React Context over prop drilling, scoped close to consumers
- File naming: kebab-case for non-components, PascalCase for components
- Testing: Use Vitest for unit tests, React Testing Library for component tests (avoid jsdom), Playwright for E2E tests
- State Management: Local hooks for simple state, useReducer for grouped state changes, React Context over prop drilling, XState for complex event-based state management and actor model
- Avoid: Multiple useState hooks in one component, boolean-driven state proliferation

#### Other Languages

- [Add sections for other languages you work with]

## UI/UX Guidelines

### Text Standards

- **Call to action buttons**: Always use sentence case (e.g.,
  "Save changes", "Remove all overrides", "Reset to default")
- [Add more UI text conventions]

### Component Patterns

- Styling: Default to Tailwind CSS, alternatives: Chakra UI, CSS Modules, Emotion (CSS-in-JS only, no styled-components)
- [Naming conventions for components]
- [Accessibility requirements]

## Project Structure & Organization

### File Organization

- Use layer-based folder structure (e.g., `/components/`, `/services/`, `/utils/`, `/hooks/`, `/types/`)
- [Naming conventions for files/folders]
- [Where to place different types of files]

### Documentation Standards

- JSDoc: Use for functions/components when meaningful and relevant
- README files: Keep short, concise, scannable - use tables, hierarchies, diagrams (Mermaid) over verbose text
- Inline comments: Explain "why" not "what", only when reasoning isn't obvious from code
- Focus on documenting intent and reasoning, not implementation details
- Avoid verbose documentation that's hard to maintain and becomes outdated

## Development Workflow

### Git & Version Control

- Commit messages: Prefer conventional commits format (feat:, fix:, chore:) when generated by AI/agents
- Manual commits: Single line summary, empty line, then optional longer description
- Branch naming: `feature/description-kebab-case` or GitHub issue-generated branch names
- [PR/MR guidelines]

### Testing

- [Testing philosophy]
- Test files: Co-locate test files next to source files (e.g., `Button.tsx`, `Button.test.tsx`)
- Test naming: Use `.test.ts(x)` for unit tests, `.spec.ts(x)` for E2E tests
- [Coverage requirements]

### Build & Deploy

- Build tool: Vite for all projects by default (unless using Next.js)
- [Environment management]
- [Deployment considerations]

### CI/CD & GitHub Actions

- Quality checks workflow: Run on PRs targeting primary branch (dev/main) - includes linting, TypeScript checking, formatting
- Test workflows: Separate workflows for unit tests and E2E tests (Playwright)
- Triggers: On PR creation/update, when code is pushed to branches with PRs targeting primary branch

## Communication & Interaction Style

### Response Format

- Keep responses concise and scannable
- Use numbered lists for questions to enable numbered responses
- When presenting options, only show truly viable/recommended choices
- Make clear recommendations when there's a preferred approach
- Ask specific, targeted questions rather than open-ended ones

### Proactivity Level

- [When to be proactive vs wait for instructions]
- [Types of suggestions to make/avoid]
- [Error handling approach]

## Security & Best Practices

### Security Guidelines

- API keys/secrets: Use .env and .env.local files locally, GitHub secrets for CI/CD, platform-specific env vars (e.g., Vercel)
- [Authentication/authorization patterns]
- [Input validation]
- [Security anti-patterns to avoid]

### LLM & MCP Security

- [Preventing sensitive data leaks to LLMs]
- [MCP server security considerations]
- [Data sanitization before sending to AI services]

### Performance Considerations

- [Performance patterns to follow]
- [Optimization priorities]
- [Resource management]

## Tool Usage Preferences

### Preferred Tools & Libraries

- Package manager: pnpm (including for monorepos)
- Formatting: Prettier with default settings
- Linting: ESLint with eslint.config.js
- Common scripts in package.json:
  - `dev` or `start`: Development server
  - `build`: Production build
  - `test`: Unit tests
  - `test:e2e`: End-to-end tests
  - `format`: Run Prettier with -w flag
  - `format:check`: Check Prettier errors only
  - `lint`: Run ESLint
  - `lint:fix`: Fix ESLint errors

### Claude Code Specific

- [When to use TodoWrite]
- [Search strategy preferences]
- [File editing approach]

## Project-Specific Overrides

_Note: Individual projects may have their own CLAUDE.md that overrides these global settings_

## Raw Ideas / To Be Organized

[Dump your ideas here and ask Claude to help organize them into the sections above]

---

_Last updated: 2025-08-14_
